/**
 * Tema 1 SO - Hashtable
 *
 * Copyright (C) 2014, Flavius Tirnacop 331CA <flavius.tirnacop@cti.pub.ro>
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 *
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "debug.h"
#include "utils.h"
#include "functii.h"


/**
 * Allocate memory for hashtable
 */
Hashtable *create_Hashtable(unsigned int size){
	Hashtable *hash;
	int i;

	DIE(size<1,"Invalid size");

	/* Allocate memory for whole hashtable */
	hash = malloc(sizeof(Hashtable));
	if(hash == NULL)  return NULL;

	/* Allocate memory for the buckets */
	hash->buckets = calloc(size,sizeof(Nod*));
	if(hash->buckets == NULL)  return NULL;

	/* Allocated initial nodes */
	for(i = 0 ; i < size ; i++){
		hash->buckets[i] = NULL;
	}

	hash->size = size;

	return hash;
}

/**
 * Adds a specified word into the hashtable
 * at a key generated by hash_function
 */
int Hash_add(char* word,Hashtable* hash){

	/* Compute hash index */
	unsigned int index = hash_function(word,hash->size);
	dprintf("Added word has bucket index %u\n", index);
	Nod *nod_nou,*nod;

	nod_nou = malloc(sizeof(Nod));
	/* Check if allocate did succede */
	if(nod_nou == NULL) return -1;
	nod_nou->next = NULL;
	nod_nou->cuvant = strdup(word);
	
	/* Get Node bucket */
	nod = hash->buckets[index];

	/* If first element add it and end*/
	if(nod == NULL){
		hash->buckets[index] = nod_nou;
		return 1;
	}
	
	/* Check for duplicates */
	while(nod->next != NULL){
		if(strcmp(word,nod->cuvant) == 0){
			/* Word already exists */
			return 2;
		}
		nod = nod->next;
	}

	/* Add new node to the end of list */
	nod->next = nod_nou;

	return 1;
}
/**
 * Removes word from hashtable
 * Returns 1 if success -1 on fail
 */
int Hash_remove(char* word,Hashtable* hash){
	/* Compute Index */
	unsigned int index = hash_function(word,hash->size);

	Nod* nod = hash->buckets[index];
	Nod* tmp;
	/* Check if bucket has elements */
	if(nod == NULL) return -1; 

	/* If only 1 Word in bucket */
	if(nod->next == NULL){
		if(strcmp(nod->cuvant,word) == 0){
			free(nod->cuvant);
			nod = NULL;
			return 1;
		}
	}
	/* Search for Word to remove */
	while(nod->next != NULL){
		if(strcmp(nod->next->cuvant,word) == 0){
			tmp = nod->next;
			nod->next = nod->next->next;
			free(tmp);
			free(tmp->cuvant);
			return 1;
		}
		nod = nod->next;
	}
	/* Word was not found */
	return -1;
}
/**
 * Clears Hashtable
 */
int Hash_clear(Hashtable* hash){
	int i;
	Nod *nod,*tmp;
	for(i = 0; i<hash->size ; i++){
		nod = hash->buckets[i];
		/* Free each bucket */
		while(nod != NULL){
			tmp = nod;
			nod = nod ->next;
			tmp->next = NULL;
			free(tmp->cuvant);
			free(tmp);			
		}
	}
	return 1;
}

/**
 * Searches for a word in the hashtable
 * If file is provided prints True/False
 * If file is not provided prints True/False at console (stdout)
 */
int Hash_find(char* word,char* outfile,Hashtable* hash){
	FILE* g;
	/* Compute Index */
	unsigned int index = hash_function(word,hash->size);
	int found = 0;
	Nod* nod = hash->buckets[index];

	/* Search trough Node list at entry index */
	while(nod != NULL){
		if(strcmp(nod->cuvant,word) == 0){
			found = 1;
		}
		nod = nod->next;
	}

	/* Check if NO file was supplied */
	if(outfile == NULL)
		if(found) 
			printf("True\n");
		else
			printf("False\n");
	else{
		/* Open file in append mode */
		g = fopen(outfile,"a");
		DIE(g<0,"Error in Opening file (Hash_find)");
		if(found) 
			fprintf(g,"True\n");
		else
			fprintf(g,"False\n");
		fclose(g);
	}
	return 1;
}

/** 
 * Prints index bucket at STDOUT or in FILE 
 */
int Hash_print_bucket(unsigned int index, char* outfile,Hashtable* hash){
	
	FILE* g;
	Nod *nod;
	nod = hash->buckets[index];

	/* Open file for writing */
	if(outfile != NULL){
		g = fopen(outfile, "a");
	}

	while(nod != NULL){
		if(outfile == NULL){
			printf("%s ",nod->cuvant);
		}else{
			fprintf(g,"%s ",nod->cuvant);
		}
		nod = nod->next;
	}

	/* Print \n and close file */
	if(outfile == NULL){
			printf("\n");
	}else{
			fprintf(g,"\n");
			fclose(g);
	}
	return 1;
}

/** 
 * Prints whole hashtable at STDOUT or in FILE 
 */
int Hash_print(char* outfile,Hashtable* hash){

	FILE* g;
	Nod *nod;	
	int i;

	/* Open file for writing */
	if(outfile != NULL){
		g = fopen(outfile, "a");
	}

	for(i = 0 ; i < hash->size ; i++){
		nod = hash->buckets[i];
		/* Skip empty buckets */
		if(nod == NULL) continue;
		while(nod != NULL){
			if(outfile == NULL){
				printf("%s ",nod->cuvant);
			}else{
				fprintf(g,"%s ",nod->cuvant);
			}
			nod = nod->next;
		}

		/* Print \n and close file */
		if(outfile == NULL){
				printf("\n");
		}else{
				fprintf(g,"\n");
		}
	}
	/* Close file if opened */
	if(outfile != NULL) fclose(g);

	return 1;
}

int Hash_resize_double(Hashtable* hash){
	printf("I am in function Hash_resize_double\n");
	return 1;
}

int Hash_resize_halve(Hashtable* hash){
	printf("I am in function Hash_resize_halve\n");
	return 1;
}

/**
 * Functie de hash bazata pe djb2 a lui Dan Bernstein
 * http://www.cse.yorku.ca/~oz/hash.html
 * @return valoarea de dispersie (cheia)
 */
unsigned int hash_function(const char *str, unsigned int hash_length)
{
	unsigned int hash = 5381;
	int c;

	while ( (c = *str++) != 0 )
		hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

	return (hash % hash_length);
}

